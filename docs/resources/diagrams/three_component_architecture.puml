@startuml Three Component Architecture
!theme plain
skinparam backgroundColor white
skinparam componentBackgroundColor white
skinparam componentBorderColor black
skinparam arrowColor black

title Hatch-Validator Dual-Pattern Architecture

package "Service Layer" {
    component [PackageService] as PS {
        Version-agnostic package\nmetadata access
    }

    component [RegistryService] as RS {
        Version-agnostic registry\ndata access
    }

    component [HatchPackageValidator] as HPV {
        Comprehensive package\nvalidation orchestration
    }
}

package "Strategy Layer" {
    package "Validation Strategies" {
        component [SchemaValidation] as SV {
            Schema structure\nvalidation
        }

        component [DependencyValidation] as DV {
            Dependency structure\nvalidation
        }

        component [EntryPointValidation] as EPV {
            Entry point\nvalidation
        }

        component [ToolsValidation] as TV {
            Tools configuration\nvalidation
        }
    }
}

package "Component Chains" {
    package "Package Accessor Chain" {
        component [V121PackageAccessor] as PA121
        component [V120PackageAccessor] as PA120
        component [V110PackageAccessor] as PA110
        
        PA121 --> PA120 : delegates unchanged\nconcerns
        PA120 --> PA110 : delegates unchanged\nconcerns
    }
    
    package "Validator Chain" {
        component [V121Validator] as V121 {
            Composes: Schema, EntryPoint, Tools\nDelegates: Dependencies
        }
        component [V120Validator] as V120 {
            Composes: Schema, Dependencies\nDelegates: EntryPoint, Tools
        }
        component [V110Validator] as V110 {
            Composes: All strategies\nNo delegation
        }

        V121 ..> V120 : delegates dependencies
        V120 ..> V110 : delegates entry_point, tools
    }
    
    package "Registry Accessor Chain" {
        component [V110RegistryAccessor] as RA110
    }
}

package "Factory Layer" {
    component [HatchPkgAccessorFactory] as PAF {
        Creates package\naccessor chains
    }
    
    component [ValidatorFactory] as VF {
        Creates validator\nchains
    }
    
    component [RegistryAccessorFactory] as RAF {
        Creates registry\naccessor chains
    }
}

package "Schema Management" {
    component [SchemaRetriever] as SR {
        Coordinates schema\nfetching and caching
    }
    
    component [SchemaFetcher] as SF {
        Downloads schemas\nfrom GitHub
    }
    
    component [SchemaCache] as SC {
        Local schema\nstorage and retrieval
    }
    
    SR --> SF : fetches schemas
    SR --> SC : caches schemas
}

package "External Dependencies" {
    database "Hatch-Schemas\nRepository" as HSR {
        GitHub repository with\nversioned schema definitions
    }
    
    database "Package\nMetadata" as PM {
        hatch_metadata.json\nfiles with schema versions
    }
    
    database "Registry\nData" as RD {
        CrackingShells Package\nRegistry format
    }
}

package "Consumer Applications" {
    component [Dependency Installation\nOrchestrator] as DIO {
        Uses PackageService and\nRegistryService for\ndependency resolution
    }
    
    component [Environment\nManager] as EM {
        Uses RegistryService and\nHatchPackageValidator for\nenvironment management
    }
    
    component [CLI Tools] as CLI {
        Uses HatchPackageValidator\nfor package validation\ncommands
    }
}

' Strategy composition relationships
V121 --> SV : composes
V121 --> EPV : composes
V121 --> TV : composes

V120 --> SV : composes
V120 --> DV : composes

V110 --> SV : composes
V110 --> DV : composes
V110 --> EPV : composes
V110 --> TV : composes

' Service Layer to Component Chains
PS --> PAF : creates chains
RS --> RAF : creates chains
HPV --> VF : creates chains
HPV --> RS : uses for validation

' Factory to Component relationships
PAF ..> PA121 : creates and links
PAF ..> PA120 : creates and links
PAF ..> PA110 : creates and links

VF ..> V121 : creates and links
VF ..> V120 : creates and links
VF ..> V110 : creates and links

RAF ..> RA110 : creates

' Schema Management relationships
V121 --> SR : loads schemas
V120 --> SR : loads schemas
V110 --> SR : loads schemas

SF --> HSR : downloads from
SC --> PM : validates against

' External Data relationships
PA121 --> PM : accesses
PA120 --> PM : accesses
PA110 --> PM : accesses

RA110 --> RD : accesses

' Consumer relationships
DIO --> PS : uses
DIO --> RS : uses

EM --> RS : uses
EM --> HPV : uses

CLI --> HPV : uses

note top of PS : Provides unified interface\nto package metadata\nregardless of schema version

note top of RS : Provides unified interface\nto registry data\nregardless of registry format

note top of HPV : Orchestrates validation\nacross all component types\nwith automatic schema detection

note top of SV : Strategy Layer:\nEncapsulates validation algorithms\nfor specific concerns

note right of PA121 : Handles v1.2.1 features:\n- Dual entry points\n- Delegates dependencies

note right of PA120 : Handles v1.2.0 features:\n- Unified dependencies\n- Delegates basic fields

note right of PA110 : Terminal accessor:\n- All basic metadata\n- Separate dependencies

note left of V121 : Dual Pattern Architecture:\n• Composes: Schema, EntryPoint, Tools\n• Delegates: Dependencies to V120\n• Handles v1.2.1 features

note left of V120 : Dual Pattern Architecture:\n• Composes: Schema, Dependencies\n• Delegates: EntryPoint, Tools to V110\n• Handles v1.2.0 features

note left of V110 : Terminal validator:\n• Composes all strategies\n• No delegation needed\n• Complete validation logic

note bottom of RA110 : Handles CrackingShells\nregistry format:\n- Repository structure\n- Package existence\n- Version resolution

note top of SR : Automatic schema management:\n- Version detection\n- Cache freshness\n- GitHub integration

note bottom of DIO : Real-world usage:\n- Version-agnostic dependency access\n- Registry operations\n- Package resolution

note bottom of EM : Real-world usage:\n- Registry data refresh\n- Package validation\n- Environment coordination

note bottom of CLI : Real-world usage:\n- Package validation commands\n- Error reporting\n- Registry integration

@enduml
