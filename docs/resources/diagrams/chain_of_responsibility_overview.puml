@startuml Chain of Responsibility Overview
!theme plain
skinparam backgroundColor white
skinparam classBackgroundColor white
skinparam classBorderColor black
skinparam arrowColor black

title Chain of Responsibility + Strategy Pattern - Dual Architecture

package "Strategy Interfaces" {
    abstract class ValidationStrategy {
        <<interface>>
    }

    abstract class DependencyValidationStrategy {
        + {abstract} validate_dependencies(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
    }

    abstract class EntryPointValidationStrategy {
        + {abstract} validate_entry_point(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
    }

    abstract class ToolsValidationStrategy {
        + {abstract} validate_tools(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
    }

    abstract class SchemaValidationStrategy {
        + {abstract} validate_schema(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
    }
}

package "Abstract Base Classes" {
    abstract class ComponentBase {
        - next_component: ComponentBase
        + set_next(component: ComponentBase): ComponentBase
        + {abstract} can_handle(version_or_data): bool
        + operation(data): Any
    }
}

package "Validators" {
    abstract class Validator {
        - next_validator: Validator
        + {abstract} can_handle(schema_version: str): bool
        + {abstract} validate(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_schema(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_dependencies(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_entry_point(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_tools(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
    }

    class V121Validator {
        - schema_strategy: SchemaValidation
        - entry_point_strategy: EntryPointValidation
        - tools_strategy: ToolsValidation
        + can_handle(schema_version: str): bool
        + validate(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_schema(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_entry_point(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_tools(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_dependencies(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
    }

    class V120Validator {
        - schema_strategy: SchemaValidation
        - dependency_strategy: DependencyValidation
        + can_handle(schema_version: str): bool
        + validate(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_schema(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_dependencies(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_entry_point(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_tools(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
    }

    class V110Validator {
        - schema_strategy: SchemaValidation
        - dependency_strategy: DependencyValidation
        - entry_point_strategy: EntryPointValidation
        - tools_strategy: ToolsValidation
        + can_handle(schema_version: str): bool
        + validate(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_schema(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_dependencies(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_entry_point(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
        + validate_tools(metadata: Dict, context: ValidationContext): Tuple[bool, List[str]]
    }
}

package "Package Accessors" {
    abstract class HatchPkgAccessorBase {
        - next_accessor: HatchPkgAccessorBase
        + {abstract} can_handle(schema_version: str): bool
        + get_dependencies(metadata: Dict): Dict
        + get_entry_points(metadata: Dict): Dict
        + get_name(metadata: Dict): str
    }
    
    class V121PackageAccessor {
        + can_handle(schema_version: str): bool
        + get_entry_points(metadata: Dict): Dict
        + get_dependencies(metadata: Dict): Dict
    }
    
    class V120PackageAccessor {
        + can_handle(schema_version: str): bool
        + get_dependencies(metadata: Dict): Dict
        + get_name(metadata: Dict): str
    }
    
    class V110PackageAccessor {
        + can_handle(schema_version: str): bool
        + get_dependencies(metadata: Dict): Dict
        + get_entry_points(metadata: Dict): Dict
        + get_name(metadata: Dict): str
        + get_all_fields(metadata: Dict): Dict
    }
}

package "Registry Accessors" {
    abstract class RegistryAccessorBase {
        - _successor: RegistryAccessorBase
        + {abstract} can_handle(registry_data: Dict): bool
        + handle_request(registry_data: Dict): RegistryAccessorBase
        + package_exists(registry_data: Dict, package_name: str): bool
        + find_compatible_version(registry_data: Dict, package_name: str, constraint: str): str
    }
    
    class V110RegistryAccessor {
        + can_handle(registry_data: Dict): bool
        + package_exists(registry_data: Dict, package_name: str): bool
        + find_compatible_version(registry_data: Dict, package_name: str, constraint: str): str
        + get_package_uri(registry_data: Dict, package_name: str, version: str): str
    }
}

package "Factory Classes" {
    class ValidatorFactory {
        - {static} _validator_registry: Dict[str, Type[Validator]]
        - {static} _version_order: List[str]
        + {static} create_validator_chain(target_version: str): Validator
        + {static} register_validator(version: str, validator_class: Type[Validator]): void
    }
    
    class HatchPkgAccessorFactory {
        - {static} _accessor_registry: Dict[str, Type[HatchPkgAccessorBase]]
        - {static} _version_order: List[str]
        + {static} create_accessor_chain(target_version: str): HatchPkgAccessorBase
        + {static} register_accessor(version: str, accessor_class: Type[HatchPkgAccessorBase]): void
    }
    
    class RegistryAccessorFactory {
        - {static} _accessor_registry: Dict[str, Type[RegistryAccessorBase]]
        + {static} create_accessor_for_data(registry_data: Dict): RegistryAccessorBase
        + {static} register_accessor(version: str, accessor_class: Type[RegistryAccessorBase]): void
    }
}

' Strategy interface inheritance
ValidationStrategy <|-- DependencyValidationStrategy
ValidationStrategy <|-- EntryPointValidationStrategy
ValidationStrategy <|-- ToolsValidationStrategy
ValidationStrategy <|-- SchemaValidationStrategy

' Component inheritance relationships
ComponentBase <|-- Validator
ComponentBase <|-- HatchPkgAccessorBase
ComponentBase <|-- RegistryAccessorBase

Validator <|-- V121Validator
Validator <|-- V120Validator
Validator <|-- V110Validator

HatchPkgAccessorBase <|-- V121PackageAccessor
HatchPkgAccessorBase <|-- V120PackageAccessor
HatchPkgAccessorBase <|-- V110PackageAccessor

RegistryAccessorBase <|-- V110RegistryAccessor

' Strategy composition relationships (solid lines)
V121Validator --> SchemaValidationStrategy : composes
V121Validator --> EntryPointValidationStrategy : composes
V121Validator --> ToolsValidationStrategy : composes

V120Validator --> SchemaValidationStrategy : composes
V120Validator --> DependencyValidationStrategy : composes

V110Validator --> SchemaValidationStrategy : composes
V110Validator --> DependencyValidationStrategy : composes
V110Validator --> EntryPointValidationStrategy : composes
V110Validator --> ToolsValidationStrategy : composes

' Chain delegation relationships (dashed lines)
V121Validator ..> V120Validator : delegates dependencies
V120Validator ..> V110Validator : delegates entry_point, tools

V121PackageAccessor --> V120PackageAccessor : delegates to
V120PackageAccessor --> V110PackageAccessor : delegates to

' Factory relationships
ValidatorFactory ..> V121Validator : creates
ValidatorFactory ..> V120Validator : creates
ValidatorFactory ..> V110Validator : creates

HatchPkgAccessorFactory ..> V121PackageAccessor : creates
HatchPkgAccessorFactory ..> V120PackageAccessor : creates
HatchPkgAccessorFactory ..> V110PackageAccessor : creates

RegistryAccessorFactory ..> V110RegistryAccessor : creates

note top of ComponentBase : Universal base pattern\nimplemented by all\nthree component types

note top of ValidationStrategy : Strategy Pattern interfaces\nencapsulate validation algorithms\nfor specific concerns

note right of V121Validator : Dual Pattern Architecture:\n• Composes strategies for changed concerns\n• Delegates unchanged concerns via chain\n• Handles v1.2.1 schema features

note right of V120Validator : Dual Pattern Architecture:\n• Composes strategies for changed concerns\n• Delegates unchanged concerns via chain\n• Handles v1.2.0 unified dependencies

note right of V110Validator : Terminal validator\nImplements all strategies\nNo delegation needed

note right of V121PackageAccessor : Handles v1.2.1 dual entry points\nDelegates dependencies to v1.2.0

note right of V120PackageAccessor : Handles v1.2.0 unified dependencies\nDelegates basic fields to v1.1.0

note right of V110PackageAccessor : Terminal accessor\nImplements all metadata access

note right of V110RegistryAccessor : Terminal registry accessor\nHandles CrackingShells registry format

note bottom of ValidatorFactory : Automatically discovers\nand links validators\nfrom newest to oldest

note as DualPattern
**Dual Pattern Architecture**
• Strategy Pattern: Encapsulates validation algorithms
• Chain of Responsibility: Enables version delegation
• Composition: Changed concerns use strategies
• Delegation: Unchanged concerns use chain
end note

@enduml
